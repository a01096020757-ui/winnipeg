<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Winnipeg / MMIWG kinetic poem</title>
  <style>
    :root{
      --bg: #0b0f14;
      --text: rgba(255,255,255,.92);
      --textSoft: rgba(255,255,255,.72);
      --shadow: rgba(0,0,0,.55);
    }

    html, body { height: 100%; }
    body{
      margin: 0;
      background: var(--bg);
      overflow: hidden;
      font-family: ui-serif, Georgia, "Times New Roman", serif;
    }

    /* Background map */
    #stage{
      position: fixed;
      inset: 0;
      background-image: url("map.png"); /* <-- 네 지도 파일명으로 바꿔! */
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: saturate(1.02) contrast(1.03);
    }

    /* subtle overlay to help text readability */
    #veil{
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse at 50% 40%, rgba(0,0,0,0.08), rgba(0,0,0,0.46)),
        linear-gradient(to bottom, rgba(0,0,0,0.18), rgba(0,0,0,0.28));
      pointer-events: none;
    }

    canvas{
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    /* tiny footer hint */
    #hint{
      position: fixed;
      left: 14px;
      bottom: 12px;
      color: rgba(255,255,255,.55);
      font-size: 12px;
      letter-spacing: .02em;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="stage"></div>
  <div id="veil"></div>
  <canvas id="c"></canvas>
  <div id="hint">click: pause / resume · move mouse: drift</div>

<script>
(() => {
  const BG_OK = true; // 배경이 안 보이면 map.png 이름/경로부터 확인

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let W = 0, H = 0, DPR = 1;
  function resize(){
    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width  = W * DPR;
    canvas.height = H * DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ----- POEM TEXT -----
  const WORD_LINE = "Winnipeg, the word that does not cross the ocean";
  const BODY_LINE = "MMIWG, the body that does not make it across life";

  // “둥글게 둥글게” 느낌: 원형으로 글자 조각들이 흐르며 회전
  // 원의 중심(호수 중심) ? 화면 비율로 잡음. 필요하면 숫자만 바꿔서 위치 조정.
  const lakeCenter = () => ({
    x: W * 0.56,
    y: H * 0.30
  });

  // Red River 대략 경로 (배경 이미지 위에서 ‘강’처럼 보이는 위치로 조정해야 함)
  // 아래 점들은 "퍼센트 좌표"라서, 네 지도에서 강 위치가 다르면 여기만 튜닝하면 돼.
  const redRiverPathPct = [
    {x: 0.30, y: 0.44},
    {x: 0.33, y: 0.46},
    {x: 0.36, y: 0.48},
    {x: 0.40, y: 0.50},
    {x: 0.44, y: 0.52},
    {x: 0.48, y: 0.54},
    {x: 0.51, y: 0.57},
    {x: 0.53, y: 0.60},
    {x: 0.54, y: 0.63},
    {x: 0.55, y: 0.66}
  ];

  function pctToPx(p){ return { x: p.x * W, y: p.y * H }; }

  // polyline helpers
  function buildSegments(points){
    const pts = points.map(pctToPx);
    const segs = [];
    let total = 0;
    for(let i=0;i<pts.length-1;i++){
      const a = pts[i], b = pts[i+1];
      const dx = b.x-a.x, dy = b.y-a.y;
      const len = Math.hypot(dx,dy);
      segs.push({a,b,len});
      total += len;
    }
    return {segs, total};
  }

  function pointOnPath(path, t01){
    const {segs, total} = path;
    let d = (t01 % 1) * total;
    for(const s of segs){
      if(d <= s.len){
        const u = s.len === 0 ? 0 : d / s.len;
        return {
          x: s.a.x + (s.b.x - s.a.x) * u,
          y: s.a.y + (s.b.y - s.a.y) * u,
          ang: Math.atan2(s.b.y - s.a.y, s.b.x - s.a.x)
        };
      }
      d -= s.len;
    }
    const last = segs[segs.length-1];
    return {x:last.b.x, y:last.b.y, ang:0};
  }

  let river = buildSegments(redRiverPathPct);

  // ----- PARTICLES / SPRITES -----
  // circular “word” fragments
  const wordTokens = WORD_LINE.split(" ");
  const bodyTokens = BODY_LINE.split(" ");

  const orbiters = [];
  function initOrbiters(){
    orbiters.length = 0;
    const n = Math.max(16, wordTokens.length * 2);
    for(let i=0;i<n;i++){
      orbiters.push({
        kind: "word",
        token: wordTokens[i % wordTokens.length],
        phase: Math.random()*Math.PI*2,
        radius: (0.12 + Math.random()*0.12) * Math.min(W,H),
        speed: (0.12 + Math.random()*0.18) * (Math.random()<0.5?1:-1),
        wobble: 0.6 + Math.random()*0.7,
        size: 16 + Math.random()*8,
        alpha: 0.65 + Math.random()*0.25
      });
    }
  }
  initOrbiters();

  // MMIWG line along river + red dress “companions”
  const riverSprites = [];
  function initRiverSprites(){
    riverSprites.length = 0;

    // body text “beads”
    const m = Math.max(14, bodyTokens.length * 2);
    for(let i=0;i<m;i++){
      riverSprites.push({
        kind: "body",
        token: bodyTokens[i % bodyTokens.length],
        t: Math.random(),
        speed: 0.025 + Math.random()*0.035,
        size: 15 + Math.random()*7,
        alpha: 0.62 + Math.random()*0.22
      });
    }

    // red dress emojis (??)
    for(let i=0;i<9;i++){
      riverSprites.push({
        kind: "dress",
        token: "??",
        t: Math.random(),
        speed: 0.020 + Math.random()*0.030,
        size: 18 + Math.random()*10,
        alpha: 0.75 + Math.random()*0.20,
        sway: Math.random()*2 + 1
      });
    }
  }
  initRiverSprites();

  // mouse drift (gentle)
  let mouse = {x: W/2, y: H/2};
  window.addEventListener("mousemove", (e) => {
    mouse.x = e.clientX; mouse.y = e.clientY;
  });

  // pause toggle
  let paused = false;
  window.addEventListener("click", () => paused = !paused);

  // ----- DRAW -----
  function drawText(text, x, y, size, alpha, rotate=0, italic=false){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rotate);

    ctx.font = `${italic ? "italic " : ""}${Math.round(size)}px ui-serif, Georgia, "Times New Roman", serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // shadow for legibility
    ctx.fillStyle = `rgba(0,0,0,${Math.min(0.7, alpha)})`;
    ctx.fillText(text, 0, 2);

    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillText(text, 0, 0);

    ctx.restore();
  }

  // optional: draw faint river guide (toggle if you want to tune points)
  const DEBUG_RIVER = false;
  function drawRiverGuide(){
    ctx.save();
    ctx.strokeStyle = "rgba(255,0,0,0.18)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    redRiverPathPct.forEach((p, i) => {
      const q = pctToPx(p);
      if(i===0) ctx.moveTo(q.x,q.y);
      else ctx.lineTo(q.x,q.y);
    });
    ctx.stroke();

    ctx.fillStyle = "rgba(255,0,0,0.35)";
    redRiverPathPct.forEach((p) => {
      const q = pctToPx(p);
      ctx.beginPath();
      ctx.arc(q.x,q.y,3,0,Math.PI*2);
      ctx.fill();
    });
    ctx.restore();
  }

  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    if(!paused){
      // update river if resized (keeps path in correct places)
      river = buildSegments(redRiverPathPct);

      // clear
      ctx.clearRect(0,0,W,H);

      // drift based on mouse (subtle)
      const driftX = (mouse.x - W/2) * 0.02;
      const driftY = (mouse.y - H/2) * 0.02;

      // 1) lake orbiters
      const c = lakeCenter();
      for(const o of orbiters){
        o.phase += o.speed * dt;
        const r = o.radius * (1 + 0.06*Math.sin(o.phase*o.wobble));
        const x = c.x + Math.cos(o.phase) * r + driftX;
        const y = c.y + Math.sin(o.phase) * r + driftY;
        const rot = o.phase + Math.PI/2;

        drawText(o.token, x, y, o.size, o.alpha, rot, true);
      }

      // big center word “Winnipeg” (anchor)
      drawText("Winnipeg", c.x + driftX*0.6, c.y + driftY*0.6, 56, 0.92, 0, false);
      drawText("the word that does not cross the ocean", c.x + driftX*0.6, c.y + 64 + driftY*0.6, 18, 0.70, 0, true);

      // 2) river sprites (MMIWG line + dresses)
      for(const s of riverSprites){
        s.t = (s.t + s.speed * dt) % 1;
        const p = pointOnPath(river, s.t);

        // offset slightly to feel like “orbiting the river”
        const nX = -Math.sin(p.ang);
        const nY =  Math.cos(p.ang);
        const offset = (s.kind === "dress" ? 18 : 10) * (0.6 + 0.6*Math.sin((s.t*2*Math.PI) * (s.sway || 1)));
        const x = p.x + nX*offset + driftX*0.7;
        const y = p.y + nY*offset + driftY*0.7;

        // dresses: a bit more upright; text: angled
        const rot = (s.kind === "dress") ? (Math.sin(s.t*2*Math.PI)*0.25) : (p.ang * 0.65);

        drawText(s.token, x, y, s.size, s.alpha, rot, s.kind !== "dress");
      }

      // footer line near bottom (soft)
      drawText("MMIWG, the body that does not make it across life", W*0.50, H*0.90, 20, 0.58, 0, true);

      if(DEBUG_RIVER) drawRiverGuide();
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>